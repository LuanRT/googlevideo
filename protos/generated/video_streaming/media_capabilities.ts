// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.0
// source: video_streaming/media_capabilities.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "video_streaming";

export interface MediaCapabilities {
  videoFormatCapabilities: MediaCapabilities_VideoFormatCapability[];
  audioFormatCapabilities: MediaCapabilities_AudioFormatCapability[];
  hdrModeBitmask?: number | undefined;
}

export interface MediaCapabilities_VideoFormatCapability {
  videoCodec?: number | undefined;
  maxHeight?: number | undefined;
  maxWidth?: number | undefined;
  maxFramerate?: number | undefined;
  maxBitrateBps?: number | undefined;
  is10BitSupported?: boolean | undefined;
}

export interface MediaCapabilities_AudioFormatCapability {
  audioCodec?: number | undefined;
  numChannels?: number | undefined;
  maxBitrateBps?: number | undefined;
  spatialCapabilityBitmask?: number | undefined;
}

function createBaseMediaCapabilities(): MediaCapabilities {
  return { videoFormatCapabilities: [], audioFormatCapabilities: [], hdrModeBitmask: 0 };
}

export const MediaCapabilities: MessageFns<MediaCapabilities> = {
  encode(message: MediaCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.videoFormatCapabilities) {
      MediaCapabilities_VideoFormatCapability.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.audioFormatCapabilities) {
      MediaCapabilities_AudioFormatCapability.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.hdrModeBitmask !== undefined && message.hdrModeBitmask !== 0) {
      writer.uint32(40).int32(message.hdrModeBitmask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.videoFormatCapabilities.push(MediaCapabilities_VideoFormatCapability.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioFormatCapabilities.push(MediaCapabilities_AudioFormatCapability.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hdrModeBitmask = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaCapabilities {
    return {
      videoFormatCapabilities: globalThis.Array.isArray(object?.videoFormatCapabilities)
        ? object.videoFormatCapabilities.map((e: any) => MediaCapabilities_VideoFormatCapability.fromJSON(e))
        : [],
      audioFormatCapabilities: globalThis.Array.isArray(object?.audioFormatCapabilities)
        ? object.audioFormatCapabilities.map((e: any) => MediaCapabilities_AudioFormatCapability.fromJSON(e))
        : [],
      hdrModeBitmask: isSet(object.hdrModeBitmask) ? globalThis.Number(object.hdrModeBitmask) : 0,
    };
  },

  toJSON(message: MediaCapabilities): unknown {
    const obj: any = {};
    if (message.videoFormatCapabilities?.length) {
      obj.videoFormatCapabilities = message.videoFormatCapabilities.map((e) =>
        MediaCapabilities_VideoFormatCapability.toJSON(e)
      );
    }
    if (message.audioFormatCapabilities?.length) {
      obj.audioFormatCapabilities = message.audioFormatCapabilities.map((e) =>
        MediaCapabilities_AudioFormatCapability.toJSON(e)
      );
    }
    if (message.hdrModeBitmask !== undefined && message.hdrModeBitmask !== 0) {
      obj.hdrModeBitmask = Math.round(message.hdrModeBitmask);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaCapabilities>, I>>(base?: I): MediaCapabilities {
    return MediaCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaCapabilities>, I>>(object: I): MediaCapabilities {
    const message = createBaseMediaCapabilities();
    message.videoFormatCapabilities =
      object.videoFormatCapabilities?.map((e) => MediaCapabilities_VideoFormatCapability.fromPartial(e)) || [];
    message.audioFormatCapabilities =
      object.audioFormatCapabilities?.map((e) => MediaCapabilities_AudioFormatCapability.fromPartial(e)) || [];
    message.hdrModeBitmask = object.hdrModeBitmask ?? 0;
    return message;
  },
};

function createBaseMediaCapabilities_VideoFormatCapability(): MediaCapabilities_VideoFormatCapability {
  return { videoCodec: 0, maxHeight: 0, maxWidth: 0, maxFramerate: 0, maxBitrateBps: 0, is10BitSupported: false };
}

export const MediaCapabilities_VideoFormatCapability: MessageFns<MediaCapabilities_VideoFormatCapability> = {
  encode(message: MediaCapabilities_VideoFormatCapability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoCodec !== undefined && message.videoCodec !== 0) {
      writer.uint32(8).int32(message.videoCodec);
    }
    if (message.maxHeight !== undefined && message.maxHeight !== 0) {
      writer.uint32(24).int32(message.maxHeight);
    }
    if (message.maxWidth !== undefined && message.maxWidth !== 0) {
      writer.uint32(32).int32(message.maxWidth);
    }
    if (message.maxFramerate !== undefined && message.maxFramerate !== 0) {
      writer.uint32(88).int32(message.maxFramerate);
    }
    if (message.maxBitrateBps !== undefined && message.maxBitrateBps !== 0) {
      writer.uint32(96).int32(message.maxBitrateBps);
    }
    if (message.is10BitSupported !== undefined && message.is10BitSupported !== false) {
      writer.uint32(120).bool(message.is10BitSupported);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaCapabilities_VideoFormatCapability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaCapabilities_VideoFormatCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.videoCodec = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxHeight = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxWidth = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.maxFramerate = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.maxBitrateBps = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.is10BitSupported = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaCapabilities_VideoFormatCapability {
    return {
      videoCodec: isSet(object.videoCodec) ? globalThis.Number(object.videoCodec) : 0,
      maxHeight: isSet(object.maxHeight) ? globalThis.Number(object.maxHeight) : 0,
      maxWidth: isSet(object.maxWidth) ? globalThis.Number(object.maxWidth) : 0,
      maxFramerate: isSet(object.maxFramerate) ? globalThis.Number(object.maxFramerate) : 0,
      maxBitrateBps: isSet(object.maxBitrateBps) ? globalThis.Number(object.maxBitrateBps) : 0,
      is10BitSupported: isSet(object.is10BitSupported) ? globalThis.Boolean(object.is10BitSupported) : false,
    };
  },

  toJSON(message: MediaCapabilities_VideoFormatCapability): unknown {
    const obj: any = {};
    if (message.videoCodec !== undefined && message.videoCodec !== 0) {
      obj.videoCodec = Math.round(message.videoCodec);
    }
    if (message.maxHeight !== undefined && message.maxHeight !== 0) {
      obj.maxHeight = Math.round(message.maxHeight);
    }
    if (message.maxWidth !== undefined && message.maxWidth !== 0) {
      obj.maxWidth = Math.round(message.maxWidth);
    }
    if (message.maxFramerate !== undefined && message.maxFramerate !== 0) {
      obj.maxFramerate = Math.round(message.maxFramerate);
    }
    if (message.maxBitrateBps !== undefined && message.maxBitrateBps !== 0) {
      obj.maxBitrateBps = Math.round(message.maxBitrateBps);
    }
    if (message.is10BitSupported !== undefined && message.is10BitSupported !== false) {
      obj.is10BitSupported = message.is10BitSupported;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaCapabilities_VideoFormatCapability>, I>>(
    base?: I,
  ): MediaCapabilities_VideoFormatCapability {
    return MediaCapabilities_VideoFormatCapability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaCapabilities_VideoFormatCapability>, I>>(
    object: I,
  ): MediaCapabilities_VideoFormatCapability {
    const message = createBaseMediaCapabilities_VideoFormatCapability();
    message.videoCodec = object.videoCodec ?? 0;
    message.maxHeight = object.maxHeight ?? 0;
    message.maxWidth = object.maxWidth ?? 0;
    message.maxFramerate = object.maxFramerate ?? 0;
    message.maxBitrateBps = object.maxBitrateBps ?? 0;
    message.is10BitSupported = object.is10BitSupported ?? false;
    return message;
  },
};

function createBaseMediaCapabilities_AudioFormatCapability(): MediaCapabilities_AudioFormatCapability {
  return { audioCodec: 0, numChannels: 0, maxBitrateBps: 0, spatialCapabilityBitmask: 0 };
}

export const MediaCapabilities_AudioFormatCapability: MessageFns<MediaCapabilities_AudioFormatCapability> = {
  encode(message: MediaCapabilities_AudioFormatCapability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioCodec !== undefined && message.audioCodec !== 0) {
      writer.uint32(8).int32(message.audioCodec);
    }
    if (message.numChannels !== undefined && message.numChannels !== 0) {
      writer.uint32(16).int32(message.numChannels);
    }
    if (message.maxBitrateBps !== undefined && message.maxBitrateBps !== 0) {
      writer.uint32(24).int32(message.maxBitrateBps);
    }
    if (message.spatialCapabilityBitmask !== undefined && message.spatialCapabilityBitmask !== 0) {
      writer.uint32(48).int32(message.spatialCapabilityBitmask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaCapabilities_AudioFormatCapability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaCapabilities_AudioFormatCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.audioCodec = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numChannels = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxBitrateBps = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.spatialCapabilityBitmask = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaCapabilities_AudioFormatCapability {
    return {
      audioCodec: isSet(object.audioCodec) ? globalThis.Number(object.audioCodec) : 0,
      numChannels: isSet(object.numChannels) ? globalThis.Number(object.numChannels) : 0,
      maxBitrateBps: isSet(object.maxBitrateBps) ? globalThis.Number(object.maxBitrateBps) : 0,
      spatialCapabilityBitmask: isSet(object.spatialCapabilityBitmask)
        ? globalThis.Number(object.spatialCapabilityBitmask)
        : 0,
    };
  },

  toJSON(message: MediaCapabilities_AudioFormatCapability): unknown {
    const obj: any = {};
    if (message.audioCodec !== undefined && message.audioCodec !== 0) {
      obj.audioCodec = Math.round(message.audioCodec);
    }
    if (message.numChannels !== undefined && message.numChannels !== 0) {
      obj.numChannels = Math.round(message.numChannels);
    }
    if (message.maxBitrateBps !== undefined && message.maxBitrateBps !== 0) {
      obj.maxBitrateBps = Math.round(message.maxBitrateBps);
    }
    if (message.spatialCapabilityBitmask !== undefined && message.spatialCapabilityBitmask !== 0) {
      obj.spatialCapabilityBitmask = Math.round(message.spatialCapabilityBitmask);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaCapabilities_AudioFormatCapability>, I>>(
    base?: I,
  ): MediaCapabilities_AudioFormatCapability {
    return MediaCapabilities_AudioFormatCapability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaCapabilities_AudioFormatCapability>, I>>(
    object: I,
  ): MediaCapabilities_AudioFormatCapability {
    const message = createBaseMediaCapabilities_AudioFormatCapability();
    message.audioCodec = object.audioCodec ?? 0;
    message.numChannels = object.numChannels ?? 0;
    message.maxBitrateBps = object.maxBitrateBps ?? 0;
    message.spatialCapabilityBitmask = object.spatialCapabilityBitmask ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
